<html>
<body>
<h3>Jumble</h3>
Word X is a jumble of word Y if the letters in X can be rearranged
to give Y. For example: backwards drawbacks.
<p> Given a dictionary as input, find the largest group of words
	all of which are jumbles of eachother.

<h3>Steps</h3>
<ol>
<li> Understand the problem
<li> Understand the question
<li> Solution involves a program
	<ol type=a>
	<li> Write an algorithm.
	<li> Convince yourself that the algorithm is reasonable
	<li> Convert this to code
	<li> Learn about the language/subroutines along the way
	<li> Go from firm ground to firm ground (ie if not familiar
		with syntax, then compile often). Write small pieces
		and check that they work.
	<li> Make sure that your code corresponds to your algorithm
	<li> Do I really understand the problem? If so the solution
		is simple, clear and obvious. 
	<li> If the solution seems more complex than my understanding
		then simplify it.
	</ol>
</ol>
<h3>Solutions</h3>
<ul>
<li> <a href=words>words</a> (the dictionary)
<li> <a href=Jumble.java>Jumble.java</a>
	is an implementation of algorithm we developed in class. 
	You should check it to see if you think it works. 
	It is not as clean and
	simple as possible, that involves better understanding and more work.
	<p>
	Try running it on the list of words I have supplied.
	I placed a counter in the code so you can see it running.
	There seems to be a problem!! Can you identify it? 
	<p><i>Hint:</i> You should be able to write down a simple mathematical expression
	to convince me that you know and understand the problem.
<li> <a href=s/Jumble.java>Jumble.java</a> A java solution using a TreeMap (and the
	alternate approach). Should this approach work better than the one above?
<li> <a href=Complexity.java>Complexity.java</a> demonstrates the difference between
	the time complexity of the two versions of Jumble.java above.
<li> <a href=s/jumble2.pl>jumble2.pl</a> A version in perl which uses hashing.
</ul>
</body>
</html>
